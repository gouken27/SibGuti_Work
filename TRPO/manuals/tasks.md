# Содержиание

1. [№1. Введение в Linux](#лабораторная-работа-1-введение-в-linux)
2. [№2. Введение в Git](#лабораторная-работа-2-введение-в-git)
3. [Лабораторная работа №3](#лабораторная-работа-3)
4. [Лабораторная работа №4](#лабораторная-работа-4)
5. [Лабораторная работа №5](#лабораторная-работа-5-расширение-системы-управления-студентами)
6. [Лабораторная работа №6](#лабораторная-работа-6)
7. [Лабораторная работа №7](#лабораторная-работа-7-организация-командной-разработки-в-gitlab)
8. [Лабораторная работа №8](#лабораторная-работа-8-генератор-персонажа)
9. [Итоговый проект]()
   
# Лабораторная работа 1. Введение в Linux

**Цель работы:**

1. Изучить основные команды Bash для сбора информации о системе.
2. Освоить создание и манипулирование файлами и директориями в Bash.
3. Научиться использовать условные операторы `if` для управления выполнением скрипта.
4. Приобрести навыки резервного копирования файлов в Bash.

---

**Задание:**

Написать Bash-скрипт, который выполняет следующие действия:

1. Скрипт должен начинаться с запроса у пользователя подтверждения запуска скрипта. Запрос должен отображаться в терминале в виде:

```
Запустить выполнение скрипта (Y/N):
```

2. **Действия при подтверждении (Y):**

   a. **Создание директории `info`**
   b. **Переход в директорию `info`**
   c. **Создание файла `system.txt`**
   d. **Запись информации в файл `system.txt`:**

      i. Текущую дату и время. Используйте команду `date`.  
      ii. Имя хоста системы. Используйте команду `hostname`.  
      iii. Версию ядра Linux. Используйте команду `uname -r`.  
      iv. Имя модели процессора. Используйте комбинацию команд `lscpu`, `grep`, `awk` и `tr` для извлечения имени модели процессора из вывода команды `lscpu`.

   e. **Вывод сообщения об успехе:**

      Вывести в терминал сообщение:  
      `Информация о системе записана в файл system.txt.`

   f. **Возврат в предыдущую директорию:**

      Вернуться на один уровень выше (в директорию, из которой был запущен скрипт).

   g. **Создание директории `bacup`**  
   h. **Переход в директорию `bacup`**  
   i. **Копирование файла `system.txt`:**

      Скопировать файл `system.txt` из директории `info` в директорию `bacup`.

   j. **Вывод сообщения о создании резервной копии:**

      Вывести в терминал сообщение:  
      `Создан каталог bacup и создана копия файла ./info/system.txt.`

   k. **Возврат в предыдущую директорию:**

      Вернуться на один уровень выше (в директорию, из которой был запущен скрипт).

3. **Действия при отказе (N):**

   a. Вывести в терминал сообщение:  
      `Пока)`

---

**Пример работы скрипта (положительный сценарий):**

```bash
$ ./my_script.sh
Запустить выполнение скрипта (Y/N): Y
Информация о системе записана в файл system.txt
Создан каталог bacup и создана копия файла ./info/system.txt
```

**Пример работы скрипта (отрицательный сценарий):**

```bash
$ ./my_script.sh
Запустить выполнение скрипта (Y/N): n
Пока)
```

---

**Контрольные вопросы:**

1. Какая команда используется для создания директории в Bash?
2. Какая команда используется для перехода в другую директорию?
3. Какая команда используется для создания пустого файла?
4. Как получить текущую дату и время в Bash?
5. Как получить имя хоста в Bash?
6. Как получить версию ядра Linux в Bash?
7. Как извлечь имя модели процессора из вывода команды `lscpu`?
8. Какая команда используется для записи текста в файл, перезаписывая его содержимое?
9. Какая команда используется для добавления текста в конец файла?
10. Какая команда используется для копирования файлов и директорий?
11. Как реализовать условное выполнение команд в Bash?
12. Что такое код возврата команды и как его проверить?

---

**Рекомендации:**

- Начните с написания простого скрипта, который только запрашивает подтверждение и выводит приветственное сообщение.
- Постепенно добавляйте функциональность, проверяя каждый шаг.
- Используйте `echo` для вывода отладочной информации в терминал.
- Проверяйте скрипт на различных системах, чтобы убедиться в его переносимости.
- Используйте `man` для получения информации о командах Bash.

---

# Лабораторная работа 2. Введение в Git

**Задание 1: Инициализация приватного Git-репозитория**

1. Авторизуйтесь на платформе GitPMIK, используя свои учетные данные.
2. Создайте новый репозиторий.
3. Укажите название репозитория: `lab1`.
4. **Важно:** Сделайте репозиторий приватным, чтобы доступ к нему имели только вы.
5. Убедитесь, что репозиторий успешно создан и доступен вам.

---

**Задание 2: Настройка SSH-аутентификации для Git**

1. **Генерация SSH-ключа:**
   1. Откройте терминал (Linux, macOS) или Git Bash (Windows).
   2. Используйте команду `ssh-keygen -t ed25519 -C "for git"` для создания нового SSH-ключа.
   3. Следуйте инструкциям на экране. Вам будет предложено выбрать место для сохранения ключа (рекомендуется оставить значение по умолчанию) и ввести парольную фразу (passphrase) для дополнительной защиты ключа (можно оставить пустой).

2. **Добавление SSH-ключа на GitPMIK:**
   1. Откройте файл публичного ключа. Обычно он находится в папке `~/.ssh/` и называется `id_ed25519.pub` (если вы не меняли имя ключа при генерации). Можно открыть его командой `cat ~/.ssh/id_ed25519.pub` (Linux/macOS) или с помощью текстового редактора.
   2. Скопируйте полное содержимое файла `id_ed25519.pub`.
   3. Авторизуйтесь на GitPMIK.
   4. Найдите раздел "Settings" (или аналогичный) и затем "SSH Keys" (или "Deploy Keys").
   5. Добавьте новый SSH-ключ. Вставьте скопированное содержимое файла `id_ed25519.pub` в поле для ключа. Присвойте ключу понятное имя (например, "My laptop").
   6. Сохраните изменения.

---

**Задание 3: Клонирование приватного Git-репозитория lab1**

1. Откройте терминал (Linux, macOS) или Git Bash (Windows).
2. Перейдите в папку, где вы хотите хранить локальную копию репозитория `lab1`. Например, можно создать папку `labs` и перейти в нее: `mkdir labs && cd labs`.
3. Найдите URL репозитория `lab1` на GitPMIK. Убедитесь, что это SSH URL, начинающийся с `git@GitPMIK`. (На веб-странице репозитория обычно есть кнопка "Clone" или "Copy", где можно выбрать между HTTPS и SSH.)
4. Используйте команду `git clone <SSH_URL_репозитория>`, чтобы клонировать репозиторий. Например: `git clone git@GitPMIK:ваш_логин/lab1.git`. Замените `ваш_логин` на свой логин на GitPMIK.
5. Если все настроено правильно, Git должен склонировать репозиторий без запроса пароля.
6. Перейдите в созданную папку `lab1`: `cd lab1`.
7. Проверьте, что репозиторий успешно склонирован, выполнив команду `git status`. Вы должны увидеть сообщение, что вы находитесь на ветке `master` и что у вас нет неотслеживаемых изменений.

---

**Задание 4: Создание простой программы для ввода двух чисел в этом репозитории**

**Цель:** Написать простую программу, демонстрирующую базовый ввод и вывод данных.

**Требования к программе:**

1. Программа должна иметь функцию `main`.
2. В функции `main` должно происходить следующее:
   1. Вывод на экран строки: "Введите два числа:".
   2. Считывание двух целых чисел, введенных пользователем.
   3. (Опционально, но рекомендуется) Вывод считанных чисел на экран, чтобы убедиться, что они были прочитаны правильно.

---

**Задание 5: Фиксация локальных изменений в Git (Commit)**

1. Проверьте статус репозитория: Используйте команду `git status`. Эта команда покажет:
   - Какие файлы были изменены (modified).
   - Какие новые файлы не отслеживаются Git (untracked).
   - Какие файлы готовы к коммиту (staged).

2. **Добавьте измененные файлы в "staging area":**
   - Чтобы добавить все измененные и новые файлы, используйте команду:  
     `git add .`
   - Чтобы добавить конкретный файл, используйте команду:  
     `git add <имя_файла>`  # Например: `git add main.c`

   После добавления файлов, команда `git status` должна показать, что эти файлы находятся в "Changes to be committed".

3. **Настройка пользователя (если еще не сделано):**
   Прежде чем сделать первый коммит, вам нужно "представиться" Git. Это делается с помощью конфигурации:
   ```bash
   git config --global user.name "Ваше Имя"
   git config --global user.email "ВашаПочта@example.com"
   ```

4. **Сделайте коммит:** Используйте команду:  
   `git commit -m "Краткое описание внесенных изменений"`

   Замените "Краткое описание внесенных изменений" на понятное и информативное описание того, что вы сделали. Хорошее описание коммита помогает понять историю проекта. Например: "Исправлена ошибка в функции расчета", "Добавлена функция вывода результатов", "Обновлен README.md"

---

**Задание 6: Отправка изменений в удаленный репозиторий lab1**

1. Откройте терминал (Linux, macOS) или Git Bash (Windows).
2. Перейдите в папку `lab1`, где находится локальный репозиторий.
3. Убедитесь, что у вас есть коммиты, которые еще не отправлены на сервер. Выполните команду `git status`. Вы должны увидеть сообщение, что ваша локальная ветка опережает `origin/master` на 1 или несколько коммитов.
4. Выполните команду `git push origin master`. Эта команда отправит ваши локальные коммиты в удаленный репозиторий.
   - `git push`: команда для отправки изменений.
   - `origin`: имя удаленного репозитория (обычно по умолчанию это `origin`, указывающее на репозиторий, с которого вы клонировали).
   - `master`: имя ветки, которую вы отправляете.
5. Если у вас настроена SSH-аутентификация (Задание 2), отправка должна произойти без запроса пароля.
6. **Проверка успешной отправки:**
   1. Перейдите на страницу репозитория `lab1` на GitPMIK.
   2. Обновите страницу.
   3. Убедитесь, что ваш файл с кодом программы (например, `main.c`) появился в репозитории.
   4. Проверьте историю коммитов (commits), чтобы убедиться, что ваш коммит отображается.

---

**Задание 7: Расширение программы и отправка изменений**

**Требования к программе:**

1. Добавить функцию `sum_numbers`, которая принимает два числа в качестве аргументов и возвращает их сумму.
2. В функции `main`:
   1. Ввод двух целых чисел (как в Задании 4).
   2. Вызов функции `sum_numbers` с введенными числами в качестве аргументов.
   3. Вывод результата (суммы) на экран с поясняющим сообщением.

3. **Создайте коммит:**
   - Проверьте статус репозитория (`git status`).
   - Добавьте измененный файл в индекс (`git add main.c`).
   - Зафиксируйте изменения (`git commit -m "Добавлена функция sum_numbers и вывод результата"`).

4. **Отправьте изменения в удаленный репозиторий:**
   - Выполните команду `git push origin master`.

---

**Задание 8: Обновление файла README.md с информацией об авторе**

1. У вас должен быть файл `README.md` в вашем репозитории `lab1`. Если его нет, создайте его.
2. Вы должны иметь возможность редактировать текстовые файлы. Откройте файл `README.md` с помощью текстового редактора (например, VS Code, Notepad++, Sublime Text, nano, vim). Добавьте в файл следующую информацию (или отредактируйте существующую):

```markdown
# Лабораторная работа №2

Выполнена:
*   Студент: [Ваше имя и фамилия]
*   Группа: [Номер вашей группы]
*   Дата выполнения: [Дата выполнения задания]

Описание:
Это репозиторий для лабораторной работы №2 по предмету "Технологии разработки программного обеспечения".
Включает в себя программу для ввода двух чисел и вычисления их суммы.

Так же вы можете добавить любую другую полезную информацию о своей работе.
```

Сохраните изменения в файле `README.md`.

3. **Зафиксируйте изменения:**
   - Проверьте статус репозитория (`git status`).
   - Добавьте измененный файл в индекс (`git add README.md`).
   - Зафиксируйте изменения (`git commit -m "Обновлен README.md: добавлена информация об авторе"`).

4. **Отправьте изменения в удаленный репозиторий:**
   - Выполните команду `git push origin master`.

**Пояснения:**

- **README.md:** Файл `README.md` – это важный файл в репозитории, который содержит описание проекта, инструкции по установке и запуску, информацию об авторах и другую полезную информацию. Он часто отображается на главной странице репозитория на GitHub, GitLab и других платформах. Он написан в формате Markdown.

- **Markdown:** Markdown – это простой язык разметки, который используется для форматирования текста. Он позволяет добавлять заголовки, списки, ссылки, изображения и другие элементы форматирования.

**Проверка:**

- После отправки изменений убедитесь, что обновленный файл `README.md` отображается в вашем репозитории на git.pmik.ru с вашей информацией.

---

**Контрольные вопросы:**

1. Что такое Git и для чего он используется?
2. Объясните разницу между `git add`, `git commit` и `git push`.
3. Что такое "staging area" (индекс) в Git?
4. Как создать новый репозиторий Git?
5. Как клонировать существующий репозиторий Git?
6. Как отправить изменения в удаленный репозиторий Git?
7. Что такое ветка (branch) в Git, и как ее создать?
8. Как просмотреть историю коммитов в Git?

---

# Лабораторная работа 3

## Часть 1

### Задание:

1. **Перейдите на страницу репозитория:**
   ```
   https://git.pmik.sibsutils.ru/A.AgalakovT/library
   ```

2. **Создайте форк проекта:**
   - В правом верхнем углу страницы нажмите кнопку **Fork**.
   - Создание форка (fork) проекта - это процесс создания копии репозитория, который находится в аккаунте другого пользователя или организации, в вашем собственном аккаунте. Это позволяет вам свободно экспериментировать с кодом, вносить изменения.

3. **Клонирование репозитория:**
   - Используйте команду `git clone` для клонирования проекта, который был получен с помощью метода описанного выше.

4. **Анализ истории:**
   - Ознакомьтесь с историей развития проекта. Используйте команды `git log`, `git checkout` для перемещения между коммитами и ветвями.
   - Обратите внимание на структуру проекта, назначение различных веток и сообщения коммитов.

5. **Слияние веток (Fast-Forward):**
   - Убедитесь, что вы находитесь в ветке `master`.
   - Выполните слияние ветки `master` и ветки `search-book` с использованием алгоритма fast-forward слияния.

   > **Примечание:** Перед слиянием убедитесь, что ветка `master` не содержит новых коммитов, иначе fast-forward слияние будет невозможно.

   - Убедитесь, что слияние выполнено успешно, и история проекта изменилась соответствующим образом (без создания коммита слияния).

6. **Отладка кода (ветка `reamove-book`):**
   - Переключитесь на ветку `reamove-book` (обратите внимание на намеренную ошибку в названии ветки).
   - В данной ветке реализована функция удаления книги из библиотеки. Однако, в коде содержится ошибка, приводящая к неправильной работе функции.
   - Найдите и исправьте ошибку в функции удаления книги.

   **Подсказка:**
   - Например, если в библиотеке есть две книги:
     - Hobbit - Tolkien
     - Dune - Herbert
   - При удалении книги "Dune" (выбор пункта меню 6) и последующем просмотре каталога книг (выбор пункта меню 3), книга "Dune" все равно отображается в списке.

7. **Коммит изменений:**
   - После исправления ошибки в функции удаления книги, выполните коммит изменений. Опишите в сообщении коммита суть исправленной ошибки.

8. **Возврат в master:**
   - Переключитесь обратно на ветку `master`.

9. **Создание новой ветки:**
   - Создайте новую ветку с именем `clean-window` и переключитесь на нее.

10. **Реализация новой функции:**
    - В ветке `clean-window` реализуйте функцию очистки окна терминала.
    - Вызывайте эту функцию каждый раз, когда пользователь выбирает один из пунктов меню. Это должно приводить к очистке терминала от предыдущего меню и вывода только выбранного результата.

11. **Слияние в master:**
    - После успешной реализации функции очистки окна терминала, переключитесь обратно на ветку `master` и выполните слияние ветки `clean-window` в `master` (с использованием fast-forward слияния).

---

### Контрольные вопросы:

1. Какую ошибку вам нужно было исправить в ветке `reamove-book`? В чем заключалась причина этой ошибки?
2. Что такое ветка в Git? Зачем нужны ветки?
3. Как создать новую ветку в Git?
4. Как переключиться между ветками в Git?
5. Как удалить ветку в Git?
6. Что такое слияние (merge) в Git?
7. Что такое fast-forward слияние? В каких случаях оно возможно?
8. Как выполнить fast-forward слияние в Git?

---

## Часть 2

### Пора поработать с другом

Для выполнения данной части задания необходимо собрать команду из 2-х человек. Если получилось так, что в группе нечетное количество студентов, то человек может сделать только одну часть задания, не нужно выполнять его за обоих.

Есть проект-заготовка (https://git.pmik.sibsutis.ru/A.AgalakovT/lab3), форк которого один из членов команды должен сделать себе и позвать друга в этот проект.

1. **Войдите в GitLab:** Залогиньтесь в свою учетную запись GitLab.

2. **Перейдите в проект:** Откройте проект, в который хотите пригласить человека.

3. **Перейдите в "Manage" -> "Members":** В левом боковом меню найдите раздел "Manage" (или "Settings" в зависимости от версии GitLab) и выберите "Members".

4. **Введите имя пользователя или адрес электронной почты:** В поле "Invite member" начните вводить имя пользователя (username) или адрес электронной почты человека, которого хотите пригласить. GitLab предложит варианты из списка зарегистрированных пользователей.

5. **Выберите уровень доступа (Role):** Выберите уровень доступа для приглашаемого пользователя из выпадающего списка. Доступные роли:

   - **Guest:** Минимальный уровень доступа. Обычно только чтение issue tracker.
   - **Reporter:** Может создавать и комментировать issues, просматривать код.
   - **Developer:** Может создавать и комментировать issues, просматривать код, создавать ветки, отправлять коммиты (pull/merge requests).
   - **Maintainer:** Может управлять проектом, принимать merge requests, управлять участниками.
   - **Owner:** Полный контроль над проектом (доступно только для владельцев группы, содержащей проект). Владельцы проектов обычно также являются владельцами группы.

6. **Выберите срок действия (Optional):** Если необходимо, установите срок действия приглашения. После истечения этого срока, приглашение станет недействительным.

7. **Нажмите "Invite":** Нажмите кнопку "Invite" (или "Add to project").

---

### Распределение задач:

Каждый из членов команды выбирает себе одну из задач и выполняет ее:

#### 1 человек:

- Склонируйте ваш с другом репозиторий.
- Сделайте ветку `perimeter` и перейдите в нее.
- В данной ветке реализуйте следующие функции (1 функция = 1 коммит) в файле `perimeter.c`:
  ```c
  double circle_perimeter(double radius);
  double rectangle_perimeter(double width, double height);
  double triangle_perimeter(double side1, double side2, double side3);
  ```
- Отправьте свою ветку на удаленный репозиторий.
- Покажите свою ветку другу. Если он одобряет ваш код, то без зазрения совести перейдите на ветку `master` и выполните слияние вашей ветки и `master`.
- Не забудьте проверить, что в ветке `master` в удаленном репозитории находятся ваши изменения.

#### 2 человек:

- Склонируйте ваш с другом репозиторий.
- Сделайте ветку `area` и перейдите в нее.
- В данной ветке реализуйте следующие функции (1 функция = 1 коммит) в файле `area.c`:
  ```c
  double circle_area(double radius);
  double rectangle_area(double width, double height);
  double triangle_area(double side1, double side2, double side3);
  ```
- Отправьте свою ветку на удаленный репозиторий.
- Покажите свою ветку другу. Если он одобряет ваш код, то без зазрения совести перейдите на ветку `master` и выполните слияние вашей ветки и `master`.
- Не забудьте проверить, что в ветке `master` в удаленном репозитории находятся ваши изменения.

---

**Важное замечание:** При соблюдении инструкций по командной работе (особенно по созданию атомарных коммитов и code review), в процессе слияния изменений в ветку `master` не должно возникать конфликтов.

**Внимание!** После успешного слияния вашей ветки c `master`, может появиться текстовый редактор (обычно nano), запрашивающий у вас сообщение коммита, в котором будут зафиксированы изменения, связанные со слиянием. Просто введите понятное описание выполненных изменений, сохраните файл и закройте редактор. Это необходимо, чтобы Git создал новый коммит, отражающий факт слияния.

---

# Лабораторная работа 4

**Цель:** Практическое закрепление навыков работы с системой контроля версий Git, включая создание и слияние веток, разрешение конфликтов, а также разработка и интеграция новых функциональных возможностей в существующий проект.

Вы будете разрабатывать многофайловый проект — важный навык для разработки более крупных и сложных программ. Разделение кода на несколько файлов помогает организовать проект, улучшить читаемость и упростить поддержку.

**Основные компоненты многофайлового проекта:**

- **Исходные файлы (.c):** Содержат реализацию функций.
- **Заголовочные файлы (.h):** Содержат объявления функций, структур, констант и других элементов, которые должны быть видны в других файлах. Заголовочные файлы являются "интерфейсом" для соответствующих исходных файлов.

**Простой способ компилировать ваш проект:**
```bash
gcc –Wall –o main *.c –lm
```

---

## Задание:

### I. Подготовка проекта:

1. **Форк и клонирование:**
   - Создайте приватный форк предоставленного проекта:
     ```
     https://git.pmik.sibsutis.ru/A.AgalakovT/simple_bank_operation.git
     ```
   - Склонируйте созданный форк на свой локальный компьютер.

2. **Исследование:**
   - Тщательно изучите структуру проекта, его исходный код и функциональность. Походите по веткам `master`, `convertor`, `mortgage`. Понимание существующего кода необходимо для успешной интеграции ваших изменений.

---

### II. Разработка конвертера валют:

3. **Переход на ветку `converter`:**
   - Перейдите на существующую ветку `converter`.

4. **Расширение функциональности:**
   - В функции конвертации валют добавьте поддержку как минимум **двух новых иностранных валют** по вашему выбору (например, японская иена, китайский юань).
   - Обеспечьте корректную обработку введенных пользователем сумм и вывод результатов конвертации.

5. **Коммит и отправка изменений:**
   - Зафиксируйте внесенные изменения с помощью коммита, содержащего понятное и информативное сообщение (например, "feat: Added support for JPY and CNY in currency converter").
   - Отправьте изменения на удаленный репозиторий (ваш форк) в ветку `convertor`.

---

### III. Разрешение конфликтов при слиянии:

6. **Переключитесь обратно на ветку `master`.**

7. **Выполните слияние ветки `convertor` в ветку `master`.** Ожидается, что слияние пройдет без конфликтов.

8. **Выполните слияние ветки `mortgage` в ветку `master`.** Обязательно возникнет **конфликт в функции `main()`** (или другой, где вызываются функции из обеих веток).
   - **Разрешите конфликт**, выбрав подходящий вариант объединения кода. Убедитесь, что после разрешения конфликта программа корректно компилируется и работает.
   - Зафиксируйте решение конфликта с помощью коммита, содержащего понятное сообщение.

9. **Отправьте обновленную ветку `master` на удаленный репозиторий.**

---

### IV. Разработка меню и генератора номера карты:

10. **Создание интерактивного меню:**
    - Добавьте в функцию `main()` интерактивное меню, которое предоставляет пользователю следующие опции:
      1. Конвертер валют
      2. Калькулятор ипотеки
      3. Выход
    - **Обеспечьте корректную обработку некорректного ввода пользователя.** Программа не должна аварийно завершаться при вводе некорректных данных. Предусмотрите сообщения об ошибках и возможность повторного ввода.
    - Программа должна завершаться только при выборе пункта "Выход".

11. **Коммит:**
    - Зафиксируйте изменения, связанные с добавлением меню, с помощью коммита с понятным сообщением.

12. **Создайте новую ветку с именем `generate-number` и переключитесь на нее.**

13. **Реализация генератора номера карты:**
    - Создайте файл `generate_number.c`.
    - Реализуйте в `generate_number.c` функцию генерации номера карты. На **данном этапе достаточно простой генерации 16 случайных цифр. Алгоритм Луна не требуется.**
    - В `generate_number.h` добавьте прототип вашей функции.

14. **Коммит:**
    - Зафиксируйте изменения, связанные с генератором номера карты, с помощью коммита.

15. **Интеграция генератора в меню:**
    - В функции `main()` добавьте пункт меню для вызова функции генерации номера карты.

16. **Коммит:**
    - Зафиксируйте изменения, связанные с интеграцией генератора в меню.

17. **Тестирование:**
    - Проверьте правильность работы функции генерации номера карты.

18. **Вернитесь на ветку `master` и отправьте ветку `generate-number` на удаленный репозиторий.**

> **Слияние ветвей `master` и `generate-number` не производить!**

---

### V. Разработка калькулятора доходности вклада:

19. **Создайте новую ветку с именем `deposit` и переключитесь на нее.**

20. **Реализация калькулятора доходности вклада:**
    - Создайте файл `deposit.c`.
    - Реализуйте в `deposit.c` функцию, рассчитывающую доходность вклада (депозита) на основе введенных пользователем параметров:
      - Сумма вклада.
      - Процентная ставка (годовая).
      - Срок вклада (в месяцах).
    - Функция может возвращать только `int` число (где 0 – функция отработала верно, 1, -1 – на ваше усмотрение). Ввод и вывод значений происходит в самой функции, которую вы реализовываете. (В качестве примера можно посмотреть на функцию `convert` на ветви `Convertor`).
    - **Используйте только формулу сложных процентов с ежемесячной капитализацией процентов.** (формулу и пример можно посмотреть: https://domrfbank.ru/blog/formula-slozhnogo-protsenta/)
    - Убедитесь, что функция работает корректно.

21. **Интеграция калькулятора в меню:**
    - В функции `main()` добавьте пункт меню для вызова функции расчета доходности вклада.

22. **Сборка и тестирование:**
    - Соберите проект и убедитесь, что ваша функция работает верно, обрабатывая различные сценарии.

23. **Коммит:**
    - Зафиксируйте изменения, связанные с калькулятором доходности вклада, с помощью коммита.

---

### VI. Завершающее слияние и проверка:

24. **Переключитесь обратно на ветку `master`.**
25. **Выполните слияние ветки `generate-number` В ВЕТКУ `master`.**
26. **Выполните слияние ветки `deposit` В ВЕТКУ `master`.**
    - Если при слиянии возникают конфликты, разрешите их, выбрав подходящий вариант объединения кода. Зафиксируйте решение конфликтов с помощью коммита.

27. **Финальное тестирование:**
    - Соберите проект и тщательно проверьте, что программа работает верно. Убедитесь, что в меню отображаются все пункты и происходит корректный вызов всех реализованных функций (конвертер валют, калькулятор ипотеки, генератор номера карты, калькулятор доходности вклада).

---

### Критерии оценки:

- Корректность выполнения всех этапов задания.
- Качество кода (читаемость, структурированность, наличие комментариев).
- Правильное разрешение конфликтов при слиянии.
- Корректная работа всех реализованных функций.
- Информативные сообщения коммитов.

---

### Дополнительные рекомендации:

- Разбивайте задачу на более мелкие подзадачи и выполняйте их последовательно.
- Используйте систему контроля версий Git для отслеживания изменений и возможности отказа к предыдущим версиям.
- Пишите комментарии к коду, чтобы объяснить логику работы функций и принятые решения.
- Регулярно проверяйте работоспособность кода после внесения изменений.
- В случае возникновения вопросов обращайтесь за помощью к преподавателю или другим студентам.

---

### Контрольные вопросы:

1. Что такое коммит (commit) в Git? Как создать коммит?
2. Как отправить изменения из локального репозитория в удаленный репозиторий? Какая команда используется?
3. Как получить изменения из удаленного репозитория в локальный репозиторий? Какая команда используется?
4. Что такое слияние (merge) в Git? Как выполнить слияние ветвей?
5. Что такое конфликт слияния (merge conflict)? Как разрешить конфликт слияния?
6. С помощью команды `git log --graph` покажите, как развивался ваш проект, и особенно места слияния веток с конфликтами. Преподаватель может попросить перейти на любой коммит из вашего проекта и на любую ветку!

**Удачи в выполнении лабораторной работы!**

---

# Лабораторная работа 5. Расширение системы управления студентами

**Цель работы:** Развить существующую систему управления студентами, добавив функциональность для хранения, отображения и редактирования оценок студентов, используя при этом workflow с ветвями Git для организации разработки.

Для данной лабораторной работы вам понадобится напарник/коллега/товарищ. Не обязательно, чтобы это был тот же человек, с которым вы вместе делали 3 лабораторную. В данной лабораторной работе вы будете расширять функционал простой программы. Перед началом, как уже принято, сделайте (ПРИВАТНЫЙ) форк проекта (у кого он будет публичный минус балл), пригласите друга. Вместе с ним прочитайте wiki (там 4 страницы). Посмотрите readme. И можете выполнять данную лабораторную. Далее определите, кто и какие функции будет реализовывать. Ну и не забывайте делать code review.

**Удачи.**

---

## Исходные данные:

- У вас есть существующая система управления студентами в Git репозитории, включающая структуру `student` с полями:
  - `id` (целочисленный идентификатор студента)
  - `name` (имя студента)
  - `surname` (фамилия студента)
  - `course` (номер курса студента)

- Реализованы функции:
  - `add_student` (добавление нового студента)
  - `print_student_table` (вывод списка студентов)
  - `find_student_by_surname` (поиск студента по фамилии)
  - `delete_student` (удаление студента по фамилии)

---

## Workflow с ветвями (Git branching workflow):

1. **master ветка:** Основная ветка, содержащая стабильную версию программы.
2. **develop ветка:** Ветка разработки, куда интегрируются все новые функции и исправления.
3. **Feature branches:** Отдельные ветки для разработки каждой новой функции. Именование: `feature/<имя_функции>`, например, `feature/add-grades`.

---

## Задание (с использованием ветвей Git):

### Этап 1: Подготовка (master)

1. Убедитесь, что у вас актуальная версия ветки `master`:
   ```bash
   git checkout master
   git pull origin master
   ```

### Этап 2: Создание ветки разработки (develop)

1. Создайте и переключитесь на ветку `develop`:
   ```bash
   git checkout -b develop
   git push -u origin develop
   ```

> **Примечание:** Все последующие feature ветки создаются на основе `develop`.

### Этап 3: Разработка функциональности (Feature Branches)

Для каждой из следующих подзадач создайте отдельную feature branch на основе ветки `develop`.

#### 1. Создание ветки для изменения структуры (feature/add-grades-struct):

```bash
git checkout develop
git checkout -b feature/add-grades-struct
```

- **Изменение структуры student:** Добавьте в структуру `student` поле для хранения оценок. Это должно быть:
  - Массив целых чисел (например, `int grades[MAX_GRADES];` где `MAX_GRADES` – константа, определяющая максимальное количество оценок, например 10).
  - Поле для хранения количества оценок у студента (например, `int num_grades;`).

- Закоммитьте изменения (коммитов может быть сколь угодно, не обязательно один):
  ```bash
  git add .
  git commit -m "feature: Add grades array to Student struct"
  ```

- Отправьте ветку на удаленный репозиторий:
  ```bash
  git push origin feature/add-grades-struct
  ```

#### 2. Слияние ветки в develop:

```bash
git checkout develop
git merge feature/add-grades-struct
```

#### 3. Создание ветки для функции заполнения оценок (feature/fill-grades):

```bash
git checkout -b feature/fill-grades
```

- **Функция заполнения оценок для студента (fill_grades):** Реализуйте функцию, которая позволяет заполнять оценки для конкретного студента.

- Закоммитьте изменения (коммитов может быть сколь угодно, не обязательно один):
  ```bash
  git add .
  git commit -m "feature: Implement fill_grades function"
  ```

- Отправьте ветку на удаленный репозиторий:
  ```bash
  git push origin feature/fill-grades
  ```

#### 4. Создание ветки для функции вывода оценок по фамилии (feature/print-grades-by-surname):

```bash
git checkout develop
git checkout -b feature/print-grades-by-surname
```

- **Функция вывода оценок студента по фамилии (print_grades_by_surname):** Реализуйте функцию, которая выводит оценки студента по заданной фамилии.

- Закоммитьте изменения (коммитов может быть сколь угодно, не обязательно один):
  ```bash
  git add .
  git commit -m "feature: Implement print_grades_by_surname function"
  ```

- Отправьте ветку на удаленный репозиторий:
  ```bash
  git push origin feature/print-grades-by-surname
  ```

#### 5. Создание ветки для функции вывода оценок всех студентов (feature/print-all-grades):

```bash
git checkout develop
git checkout -b feature/print-all-grades
```

- **Функция вывода оценок всех студентов (в виде таблицы) (print_all_grades):** Реализуйте функцию, которая выводит оценки всех студентов в виде таблицы.

- Закоммитьте изменения (коммитов может быть сколь угодно, не обязательно один):
  ```bash
  git add .
  git commit -m "feature: Implement print_all_grades function"
  ```

- Отправьте ветку на удаленный репозиторий:
  ```bash
  git push origin feature/print-all-grades
  ```

#### 6. Создание ветки для функции редактирования оценок (feature/edit-grades):

```bash
git checkout develop
git checkout -b feature/edit-grades
```

- **Функция редактирования оценок (edit_grades):** Реализуйте функцию, которая позволяет редактировать оценки существующего студента.

- Закоммитьте изменения:
  ```bash
  git add .
  git commit -m "feature: Implement edit_grades function"
  ```

- Отправьте ветку на удаленный репозиторий:
  ```bash
  git push origin feature/edit-grades
  ```

#### 7. Слейте все ветки в develop

#### 8. Создание ветки для интеграции меню (feature/menu-integration):

```bash
git checkout develop
git checkout -b feature/menu-integration
```

- **Интеграция с основным меню:** Добавьте новые пункты в основное меню программы для вызова функций `fill_grades`, `print_grades_by_surname`, `print_all_grades` и `edit_grades`.

- Закоммитьте изменения:
  ```bash
  git add .
  git commit -m "feature: Integrate new functions into the main menu"
  ```

- Отправьте ветку на удаленный репозиторий:
  ```bash
  git push origin feature/menu-integration
  ```

### Этап 4: Слейте ветку develop в master

1. **Для каждой feature branch:**
   - Когда ветка `develop` протестирована и стабильна слейте ее в `master`.
   ```bash
   git checkout master
   git merge develop
   git push origin master
   ```

### Этап 5: Исправить у себя wiki, changelog и readme.

Данные изменения можно оформить как следующая версия программы, или как изменения, готовые для добавления в следующую версию.

---

## Дополнительные требования:

- **Обработка конфликтов:** Если во время слияния возникают конфликты, разрешите их.
- **Сообщения коммитов:** Пишите информативные сообщения коммитов, соответствующие общепринятым стандартам.
- **Code Review:** (Если возможно) Проводите code review для каждой feature branch перед слиянием.

---

## Критерии оценки:

- Правильность реализации функций.
- Соблюдение workflow с ветвями Git.
- Разрешение конфликтов (если они возникли).
- Качество кода (читаемость, комментарии, структура).
- Интеграция новых функций в существующую систему.

---

## Рекомендации:

- Регулярно делайте коммиты и отправляйте изменения в удаленный репозиторий.
- Задавайте вопросы, если у вас возникают трудности.

---

## ПРИЛОЖЕНИЕ 1

```c
#include <stdio.h>
#include "student.h"

void print_all_grades(Student *students, int size) {
    if (students == NULL || size <= 0) {
        printf("Нет данных для отображения.\n");
        return;
    }

    printf("------------------------------------------------------------\n");
    printf("| %-20s | %-20s | %-15s |\n", "Name", "Surname", "Оценки");
    printf("------------------------------------------------------------\n");

    for (int i = 0; i < size; i++) {
        printf("| %-20s | %-20s | ", students[i].name, students[i].surname);

        if (students[i].num_grades > 0) {
            for (int j = 0; j < students[i].num_grades; j++) {
                printf("%d", students[i].grades[j]);
                if (j < students[i].num_grades - 1) {
                    printf(", ");
                }
            }
        } else {
            printf("Нет оценок");
        }
        printf(" |\n");
    }
    printf("------------------------------------------------------------\n");
}
```

---

# Лабораторная работа 6

**Цель работы:**

Освоить навыки написания и тестирования функций на языке С.
Изучить методы тестирования, включая юнит-тесты и проверку граничных случаев.

Сделайте приватный форк репозитория с реализованными функциями, которые необходимо протестировать.

---

## Часть 1. Написание тестов для функций

| Название функции | Тесты, которые необходимо реализовать |
|------------------|----------------------------------------|
| Вычисление факториала | `factorial(0) → 1`<br>`factorial(5) → 120`<br>`factorial(-3) → -1` |
| Проверка числа на простоту | `is_prime(-5) → -1`<br>`is_prime(2) → 1`<br>`is_prime(15) → 0` |
| Подсчет гласных в строке | `count_vowels("Hello World") → 3`<br>`count_vowels("BCDFG") → 0`<br>`count_vowels(NULL) → -1` |
| Поиск максимального элемента в массиве | Массив `[3, -5, 7, 2] → 7`<br>Пустой массив `→ -1`<br>Массив `[-10, -5, -1] → -1` |
| Конвертер температуры: Цельсий → Фаренгейт | `celsius_to_fahrenheit(0) → 32`<br>`celsius_to_fahrenheit(100) → 212`<br>`celsius_to_fahrenheit(-40) → -40` |
| Проверка строки на палиндром | Тут придумайте тесты сами, но чтобы они полностью проверяли все возможные выходы |

---

## Часть 2. Исправление ошибок в функциях

Теперь пойдем с другой стороны. Есть функции, для которых уже написаны тесты, но они не проходят, ищем и исправляем ошибки.

1. **Функция для поиска индекса элемента в массиве**
2. **Функция для вычисления среднего значения массива**
3. **Функция для конвертации строки в число**

---

## Часть 3. Реализация функций по прототипам и тестам

А теперь еще интересней. Есть прототип функции и уже написаны тесты. Реализуйте для них функции.

1. **Подсчет количества цифр в числе**
2. **Проверка, является ли число четным**
3. **Поиск индекса первого вхождения элемента в массиве**

---

## Часть 4. Создание Makefile для проекта library

Для проекта `library` напишите `makefile`, в котором будут присутствовать переменные.

---

**На защите лабораторной работы будьте готовы не только представить код ваших тестов, но и продемонстрировать их запуск по требованию преподавателя.**

---

# Лабораторная работа 7. Организация командной разработки в GitLab

**Цель работы:**

Освоить основные принципы организации командной разработки в GitLab, включая управление репозиторием, ветвлением, issue-трекингом и процессом code review.

---

## Задание:

### 1. Создание и настройка приватного репозитория

- Создайте приватный репозиторий в GitLab.
- Пригласите свою команду (разработчиков) в репозиторий, назначив им роль **Developer**.
- Настройте защищенную ветку `main/master`:
  - Запретите прямой push в ветку.
  - Разрешите merge только после approve (вашего или других maintainers).

### 2. Планирование проекта (Milestones)

- Создайте **Milestones** (этапы разработки).
- Заполните хотя бы первый Milestone задачами (см. следующий пункт).

### 3. Создание Issues и распределение задач

- Создайте **Issues** для первого этапа разработки.
- Назначьте задачи разработчикам (**Assignee**).
- Привяжите Issues к первому Milestone.

### 4. Настройка Merge Request (MR) политики

- Обязательный **approve** от вас.
- Запретить push в ветку `master/main`.

### 5. Проверка работоспособности процесса

- Разработчики должны:
  - Создать ветки от `main` (или `develop`), например: `feature/auth-api`.
  - Сделать изменения, отправить их в репозиторий.
  - Создать **Merge Request**, указав связанный **Issue**.
- Вы проверяете код, ставите **approve** или запрашиваете правки.
- После **approve** изменения мержатся в `main` (или `develop`).

---

# Лабораторная работа 8. Генератор персонажа

## 1. Цель работы

Освоить работу с библиотекой libui для создания графических приложений на языке C, научиться обрабатывать пользовательский ввод, реализовывать логику программы и выводить результаты в удобном формате.

## 2. Задание

Разработать программу "Генератор персонажей для RPG", которая:

1. Позволяет пользователю выбрать расу персонажа и ввести его имя.
2. Генерирует случайные характеристики (сила, ловкость, интеллект) с учетом расовых модификаторов.
3. Выводит информацию о персонаже в удобном формате.
4. Включает дополнительный функционал (чекбокс сложности, символы рас).

---

### Требования к программе:

#### Обязательная часть (максимум оценка 4):

- Использование элементов libui: `uiCombobox`, `uiEntry`, `uiButton`, `uiMultilineEntry`.

Создать программу, которая генерирует персонажа для компьютерной игры (как в RPG).

Программа должна:

- **Спрашивать у пользователя:**
  - Имя персонажа (текстовое поле)
  - Расу персонажа (выпадающий список с вариантами: Человек, Эльф, Гном, Орк)

- **При нажатии кнопки "Создать" программа:**
  - Генерирует случайные числа от 1 до 20 для:
    - Силы
    - Ловкости
    - Интеллекта
  - Добавляет бонусы в зависимости от расы:
    - Орк: +3 к силе, -2 к интеллекту
    - Эльф: +3 к ловкости, -2 к силе
    - Гном: +3 к интеллекту, -2 к ловкости
    - Человек: без бонусов
  - Вывод информации в формате:
    ```
    Имя: [имя]
    Раса: [раса]
    Сила: [значение]
    Ловкость: [значение]
    Интеллект: [значение]
    ```

#### Дополнительная часть (максимум оценка 5):

- Добавление символов рас с помощью смайликов.
- Проверка ввода имени (запрет пустого имени).
- А третье усложнение придумайте сами. Например, можно спрятать пасхалку)

---

**Проект должен храниться в приватном репозитории на gitlab**

**Просто следуйте примеру с лекции и у вас всё получится! 😊**