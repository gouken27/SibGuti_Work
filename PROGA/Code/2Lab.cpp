#include "Database.hpp"
#include <iostream>

/**
 * @brief 1. Реализация рекурсивного ввода/вывода.
 */
void readAndPrintPositive() {
    int num;
    std::cin >> num;

    // Базовый случай рекурсии:
    // Если ввели 0, прекращаем ввод и начинаем "размотку" стека.
    if (num == 0) {
        return;
    }

    // Рекурсивный вызов:
    // Сначала вызываем функцию для следующего числа.
    readAndPrintPositive();

    // Действие "на обратном ходу":
    // Этот код выполнится *после* того, как рекурсия
    // дошла до 0 и начала возвращаться обратно.
    // Поэтому числа печатаются в обратном порядке.
    if (num > 0) {
        std::cout << num << " ";
    }
}

/**
 * @brief Вспомогательная рекурсивная функция для printNegPos.
 * @param arr Массив.
 * @param n Размер.
 * @param index Текущий индекс.
 */
static void printNegPosRecursive(int arr[], int n, int index) {
    // Базовый случай:
    // Если дошли до конца массива, останавливаемся.
    if (index == n) {
        return;
    }

    // Действие "на прямом ходу":
    // Если число отрицательное, печатаем его сразу.
    if (arr[index] < 0) {
        std::cout << arr[index] << " ";
    }

    // Рекурсивный вызов:
    // Переходим к следующему элементу.
    printNegPosRecursive(arr, n, index + 1);

    // Действие "на обратном ходу":
    // Этот код выполнится, когда рекурсия дойдет до конца
    // и начнет возвращаться.
    // Если число положительное, печатаем его.
    if (arr[index] > 0) {
        std::cout << arr[index] << " ";
    }
}

/**
 * @brief 2. Функция-обертка, которую вызывает пользователь.
 * Она скрывает детали реализации (например, начальный индекс).
 */
void printNegPos(int arr[], int n) {
    // Вызываем рекурсивную функцию с начальным индексом 0
    printNegPosRecursive(arr, n, 0);
    std::cout << std::endl; // Для чистоты вывода
}

/**
 * @brief 3. Реализация перевода в двоичную систему.
 */
void decimalToBinary(int n) {
    // Базовый случай:
    // Если число больше 1, продолжаем деление.
    if (n > 1) {
        decimalToBinary(n / 2);
    }

    // Действие "на обратном ходу":
    // Печатаем остаток от деления на 2.
    // Из-за "размотки" стека цифры печатаются в правильном порядке.
    std::cout << (n % 2);
}