1. Понятие идентификатора.
Идентификатор — имя, используемое для обозначения переменных, функций, массивов и других объектов в программе. Состоит из букв, цифр и знака подчеркивания, начинается с буквы или подчеркивания.

2. Определение переменной.
Переменная — именованная область памяти для хранения данных определенного типа, объявляется указанием типа и имени.

3. Основные типы переменных.
int, float, double, char, short, long, unsigned, bool.

4. Типы операций в языке Си.
Арифметические (+, -, *, /, %), логические (&&, ||, !), побитовые (&, |, ^, ~, <<, >>), присваивания (=, +=, -=, *=, /=), сравнения (==, !=, <, >, <=, >=), инкремент/декремент (++, --).

5. Структура программы на языке Си.
Включает заголовочные файлы, объявления функций, глобальные переменные, функцию main() и другие функции.

6. Для чего используются заголовочные файлы?
Для подключения библиотек, объявления функций, макросов и типов данных (например, stdio.h для ввода-вывода).

7. Как откомпилировать программу?
С помощью компилятора, например: gcc program.c -o program.

8. Как выполнить программу?
Запустить скомпилированный файл, например: ./program (в Linux) или program.exe (в Windows).

9. Как просмотреть результат выполнения?
Результаты выводятся в консоль (printf) или в файл, в зависимости от программы.

10. Сравните виды условных операторов Си.
if (условие), if-else, вложенные if, switch-case. if проверяет одно условие, if-else — альтернативы, switch — множественный выбор.

11. Всегда ли ставятся скобки и какие в условном операторе?
Скобки {} обязательны для составных операторов, для одиночных можно опустить. Используются фигурные скобки.

12. Приведите пример условного оператора.
if (a > b) {
    printf("a больше b\n");
} else {
    printf("a не больше b\n");
}

13. Чем отличается простой оператор от составного оператора?
Простой — одна инструкция, составной — блок инструкций в {}.

14. Зачем ставятся в переключателе операторы break и default?
break завершает выполнение case, предотвращая переход к следующему. default выполняется, если ни один case не подходит.

15. Как будет работать программа из примера без break?
Без break выполнение продолжится для всех последующих case, пока не встретится break или конец switch.

16. Приведите пример оператора switch.
switch (x) {
    case 1: printf("Один\n"); break;
    case 2: printf("Два\n"); break;
    default: printf("Другое\n");
}

17. Какие выражения записываются в заголовке цикла? Правила записи этих выражений?
В for: инициализация; условие; шаг. Например: for (int i = 0; i < n; i++). Выражения разделяются точкой с запятой.

18. Когда завершается выполнение цикла?
Когда условие в заголовке цикла становится ложным.

19. По какой причине может произойти зацикливание (цикл становится бесконечным)?
Условие цикла всегда истинно из-за ошибки в логике (например, i++ забыто в for).

20. Как можно досрочно выйти из цикла?
С помощью оператора break.

21. Как можно досрочно перейти к новому шагу цикла?
С помощью оператора continue.

22. Понятие массива.
Массив — набор элементов одного типа, хранящихся в непрерывной области памяти.

23. Объявление массива.
Тип имя[размер]; Например: int arr[10];

24. Доступ к элементам массива.
Через индекс: arr[i], где i — индекс (начинается с 0).

25. Ввод-вывод массива.
Ввод: for (int i = 0; i < n; i++) scanf("%d", &arr[i]);
Вывод: for (int i = 0; i < n; i++) printf("%d ", arr[i]);

26. Заполнение массива случайными числами.
Используя rand(): for (int i = 0; i < n; i++) arr[i] = rand() % max;

27. Как просматриваются элементы массива при линейном поиске?
Последовательно проверяется каждый элемент: for (int i = 0; i < n; i++) if (arr[i] == key) ...

28. Зачем вводится переменная «флаг»?
Для обозначения состояния (например, найдено/не найдено): int flag = 0;

29. Какую переменную программисты называют «счётчиком»?
Переменную (обычно i, j), используемую для подсчета итераций в циклах.

30. Что такое сортировка массива?
Упорядочивание элементов массива по заданному критерию (например, по возрастанию).

31. Принцип сортировки методом пузырька.
Сравниваются соседние элементы, если порядок неверный — меняются местами, повторяется до упорядочивания.

32. Каковы индексы первого и последнего элементов массива, объявленного как float y[n];?
Первый: 0, последний: n-1.

33. Как сформировать массив значений функции на интервале [a,b] при заданном шаге или количестве значений функции?
Шаг h = (b-a)/(n-1); for (int i = 0; i < n; i++) y[i] = f(a + i*h);

34. Как вычислить сумму элементов массива, исключая крайние элементы?
for (int i = 1; i < n-1; i++) sum += arr[i];

35. Как вычислить сумму нечётных и чётных элементов массива?
Чётные индексы: for (int i = 0; i < n; i+=2) even_sum += arr[i];
Нечётные: for (int i = 1; i < n; i+=2) odd_sum += arr[i];

36. Как объявить матрицу? Как инициализировать?
Объявление: int matrix[m][n];
Инициализация: int matrix[2][2] = {{1, 2}, {3, 4}};

37. Ввод-вывод матрицы по строкам.
Ввод: for (int i = 0; i < m; i++) for (int j = 0; j < n; j++) scanf("%d", &matrix[i][j]);
Вывод: for (int i = 0; i < m; i++) { for (int j = 0; j < n; j++) printf("%d ", matrix[i][j]); printf("\n"); }

38. Как поменять местами строки в матрице?
for (int j = 0; j < n; j++) { int temp = matrix[i1][j]; matrix[i1][j] = matrix[i2][j]; matrix[i2][j] = temp; }

39. Как найти минимальный элемент матрицы и его индексы?
min = matrix[0][0]; for (int i = 0; i < m; i++) for (int j = 0; j < n; j++) if (matrix[i][j] < min) { min = matrix[i][j]; min_i = i; min_j = j; }

40. Как вычислить сумму элементов строки матрицы?
sum = 0; for (int j = 0; j < n; j++) sum += matrix[i][j];

41. Как получить транспонированную матрицу?
Создать новую матрицу: for (int i = 0; i < m; i++) for (int j = 0; j < n; j++) trans[j][i] = matrix[i][j];

42. Инициализация символов и строк.
Символ: char c = 'A';
Строка: char str[] = "Hello";

43. Ввод и вывод символов и строк.
Символ: scanf("%c", &c); printf("%c", c);
Строка: scanf("%s", str); printf("%s", str);

44. Функция strlen.
Возвращает длину строки (без учета '\0'): strlen(str).

45. Функции strcmp, strncmp.
strcmp сравнивает строки полностью, strncmp — до n символов. Возвращают <0, 0, >0 в зависимости от порядка.

46. Функции strcpy, strncpy.
strcpy копирует строку полностью, strncpy — до n символов.

47. Функции strcat, strncat.
strcat добавляет строку к другой, strncat — до n символов.

48. Функции strchr, strstr.
strchr ищет первое вхождение символа, strstr — подстроки. Возвращают указатель или NULL.

49. Описание функции.
Функция — блок кода с именем, выполняющий задачу. Состоит из возвращаемого типа, имени, параметров и тела.

50. Где может быть описана функция? Для чего объявляется прототип?
Описана до или после main(). Прототип объявляется для информирования компилятора о функции до ее вызова.

51. Что такое формальные и фактические параметры?
Формальные — параметры в объявлении функции, фактические — значения, передаваемые при вызове.

52. Какие переменные называют глобальными, и какие локальными?
Глобальные — объявлены вне функций, доступны везде. Локальные — внутри функции, доступны только в ней.

53. Способы вызова функций.
По значению (копия), по указателю, по ссылке (в C++).

54. Что такое рекурсия?
Функция вызывает сама себя для решения задачи.

55. Где хранятся локальные переменные при выполнении рекурсии?
В стеке вызовов, для каждого вызова создается новый экземпляр.

56. Как меняются локальные переменные в рекурсиях?
Каждый вызов имеет свои копии локальных переменных, независимые от других.

57. Как закончить рекурсию?
Задать базовый случай, при котором функция возвращает результат без повторного вызова.

58. Достоинства и недостатки рекурсивных программ.
Достоинства: компактный код, решение сложных задач. Недостатки: переполнение стека, высокая вычислительная сложность.

59. Где хранятся адреса динамических переменных?
В указателях, выделенных через malloc/calloc.

60. Как выделить память под простую динамическую переменную?
int *p = (int*)malloc(sizeof(int));

61. Как выделить память под одномерный динамический массив?
int *arr = (int*)malloc(n * sizeof(int));

62. Как освободить динамическую память?
С помощью free(p);

63. Какое значение будет иметь указатель после освобождения памяти?
Неопределенное, использовать нельзя.

64. Как выделить память под двумерный динамический массив при заранее известной длине строки?
int matrix = (int)malloc(m * sizeof(int*));
for (int i = 0; i < m; i++) matrix[i] = (int*)malloc(n * sizeof(int));

65. Как задать новый тип «массив»?
Через typedef: typedef int Array[n];

66. Как освободить динамическую память, выделенную под матрицу?
for (int i = 0; i < m; i++) free(matrix[i]); free(matrix);

67. Какое значение будет иметь указатель после освобождения памяти?
Неопределенное, использовать нельзя.

68. Отличия динамического массива от статического.
Статический: фиксированный размер, выделяется на этапе компиляции. Динамический: размер задается в runtime, выделяется через malloc.

69. Как создать одномерный динамический массив?
int *arr = (int*)malloc(n * sizeof(int));

70. Как создать динамическую матрицу?
См. вопрос 64.

71. Как освобождается память, занятая под динамические структуры?
С помощью free() для каждого выделенного блока.

72. Как передать результаты выполнения функции через параметры-указатели?
Передача адреса: void func(int *result) { *result = value; }

73. Как передать результаты выполнения функции через параметры-ссылки?
В C++: void func(int &result) { result = value; }

74. Какое требование предъявляется к фактическим параметрам-указателям?
Должны быть адресами переменных (например, &x).

75. Какое требование предъявляется к фактическим параметрам-ссылкам?
Должны быть переменными, совместимыми по типу.

76. Как в С++ передаётся в функцию массив?
Как указатель: void func(int arr[], int n) или void func(int *arr, int n).

77. Требуется ли в параметре функции указывать размер одномерного массива?
Нет, но обычно передается отдельным параметром.

78. Как можно передавать матрицу в функцию?
Как двумерный массив: void func(int matrix[][n], int m) или указатель на указатель: void func(int **matrix, int m, int n).

79. Какие границы измерений задаются в параметре функции при передаче многомерного массива?
Все, кроме первого измерения: void func(int matrix[][n], int m).

80. Какие типы данных относятся к простым, а какие к составным?
Простые: int, float, char, double. Составные: массивы, структуры, объединения.

81. Как объявляются структуры, и чем отличается структура от массива?
struct Name { тип поле; ... }; Структура хранит разнотипные данные, массив — однотипные.

82. Как обращаться к полям структуры?
Через точку (struct_name.field) или стрелку для указателей (ptr->field).

83. Какие операции допустимы над структурой в целом?
Присваивание, передача в функцию, возврат из функции.

84. Чем отличается файл от массива?
Файл — данные на диске, массив — данные в оперативной памяти.

85. Особенности организации текстовых файлов.
Хранят данные в символьном виде, разделены символами (например, \n).

86. Что понимается под чтением, и что под записью в файл?
Чтение — получение данных из файла, запись — сохранение данных в файл.

87. Режимы доступа к файлам.
"r" (чтение), "w" (запись), "a" (добавление), "r+" (чтение/запись), "w+" (создание/чтение/запись), "a+" (добавление/чтение).

88. Как создать бинарный файл?
fopen("file.bin", "wb"); fwrite(data, size, count, file);

89. Назначение функций fseek, ftell.
fseek — перемещает указатель позиции в файле, ftell — возвращает текущую позицию.

90. Как создать бинарный файл?
См. вопрос 88.