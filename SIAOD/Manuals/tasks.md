# Задания (Лабораторных) по СиАОД

### 1 блок : задания по алгоритмам обработки массивов

## 1.1 Задание по сортировке прямого выбора SelectSort

**Задание:** Разработать подпрограмму сортировки массива целых чисел по возрастанию методом прямого выбора (`SelectSort`).

## 1. Реализация

**Требования к проверке:**
* **Корректность:** Проверить правильность сортировки путем подсчета контрольной суммы элементов и числа серий в массиве.
* **Метрики:** Предусмотреть подсчет фактического количества пересылок $M$ и сравнений $C$.
* **Сравнение:** Сравнить полученные данные с теоретическими оценками ($M$ и $C$) для различных типов массивов.

## 2. Исследование зависимости от данных
Исследовать работу метода `SelectSort` на трех типах массивов:
1. Убывающие числа.
2. Возрастающие числа.
3. Случайные числа.

> **Цель:** Сделать вывод о зависимости (или независимости) метода `SelectSort` от исходной упорядоченности массива.

## 3. Оптимизация алгоритма
1. Придумать способ устранения **фиктивных перестановок** (ситуация, когда элемент меняется сам с собой).
2. Оценить влияние этого изменения на фактические значения $M_{ф}$ и $C_{ф}$.
3. Исследовать улучшенный метод на тех же типах массивов (убывающих, возрастающих, случайных) и сделать выводы.

## 4. Сводная таблица трудоемкости

| $$N$$| Теор.$$M+C$$ | Исх. (Убыв.)$$M_{ф} + C_{ф}$$ | Исх. (Случ.)$$M_{ф} + C_{ф}$$ | Исх. (Возр.)$$M_{ф} + C_{ф}$$ | Улучш. (Убыв.)$$M_{ф} + C_{ф}$$ | Улучш. (Случ.)$$M_{ф} + C_{ф}$$ | Улучш. (Возр.)$$M_{ф} + C_{ф}$$ |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| **10** | | | | | | | |
| **100** | | | | | | | |

## 5. Визуализация результатов
Построить на экране в координатной плоскости график зависимости суммарной трудоемкости $M_{ф}$ + $C_{ф}$ от размера массива n для метода `SelectSort` (для массива случайных чисел).

## 1.2. Задания по пузырьковой сортировке BubbleSort

**Задание:** Разработать подпрограмму пузырьковой сортировки (`BubbleSort`) для массива целых чисел по возрастанию.

## 1. Реализация

**Требования к проверке:**
* **Корректность:** Проверить правильность сортировки путем подсчета контрольной суммы элементов и числа серий в массиве.
* **Метрики:** Предусмотреть подсчет фактического количества пересылок $M_{ф}$ и сравнений $C_{ф}$.
* **Сравнение:** Сравнить полученные данные с теоретическими оценками $M$ и $C$.

## 2. Исследование зависимости от данных
Сравнить время работы по сумме трудоемкости $M_{ф}+C_{ф}$ метода `BubbleSort` на трех типах массивов:
1. Убывающие числа.
2. Возрастающие числа.
3. Случайные числа.

> **Цель:** Сделать вывод о зависимости (или независимости) метода `BubbleSort` от исходной упорядоченности массива.

## 3. Таблица трудоемкости
Заполните таблицу результатов для различных размерностей массива $N$.

| $$N$$| Теор.$$M+C$$| (Убыв.)$$M_{ф} + C_{ф}$$| (Случ.)$$M_{ф} + C_{ф}$$| (Возр.)$$M_{ф} + C_{ф}$$ |
| :---: | :---: | :---: | :---: | :---: |
| **100** | | | | |
| **200** | | | | |
| **300** | | | | |
| **400** | | | | |
| **500** | | | | |

## 4. Визуализация и сравнение
**Задание повышенной сложности:**
Построить на экране в координатной плоскости график зависимости суммарной трудоемкости $$M_{ф}+C_{ф}$$ от размера массива n.

На одном графике необходимо отобразить кривые для двух методов (для массива случайных чисел):
1. Метод прямого выбора (**SelectSort**).
2. Пузырьковая сортировка (**BubbleSort**).

## 1.3. Задания по шейкерной сортировке ShakerSort

**Задание:** Разработать подпрограмму шейкерной сортировки (`ShakerSort`) для массива целых чисел по возрастанию.

## 1. Реализация

**Требования к проверке:**
* **Корректность:** Проверить правильность сортировки путем подсчета контрольной суммы элементов и числа серий в массиве.
* **Метрики:** Предусмотреть подсчет фактического количества пересылок Mф и сравнений Cф.
* **Сравнение:** Сравнить полученные данные с теоретическими оценками M и C.

## 2. Исследование зависимости от данных
Сравнить время работы по сумме трудоемкости $$M_{ф}+C_{ф}$$ метода `ShakerSort` на трех типах массивов:
1. Убывающие числа.
2. Возрастающие числа.
3. Случайные числа.

> **Цель:** Сделать вывод о зависимости (или независимости) метода `ShakerSort` от исходной упорядоченности массива.

## 3. Таблица трудоемкости
Заполните таблицу результатов для различных размерностей массива N, сравнивая с пузырьковой сортировкой.

| $$N$$| Пузыр. (Убыв.)$$M_{ф} + C_{ф}$$| Пузыр. (Случ.)$$M_{ф} + C_{ф}$$| Пузыр. (Возр.)$$M_{ф} + C_{ф}$$ | Шейк. (Убыв.)$$M_{ф} + C_{ф}$$ | Шейк. (Случ.)$$M_{ф} + C_{ф}$$ | Шейк. (Возр.)$$M_{ф} + C_{ф}$$ |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| **100** | | | | | | |
| **200** | | | | | | |
| **300** | | | | | | |
| **400** | | | | | | |
| **500** | | | | | | |

## 4. Визуализация и сравнение
**Задание повышенной сложности:**
Построить на экране в одной координатной плоскости графики зависимости суммарной трудоемкости $$M_{ф}+C_{ф}$$ от размера массива n.

На одном графике необходимо отобразить кривые для трех методов (для массива случайных чисел):
1. Метод прямого выбора (**SelectSort**).
2. Пузырьковая сортировка (**BubbleSort**).
3. Шейкерная сортировка (**ShakerSort**).

## 1.4. Задания по сортировке прямого включения InsertSort

**Задание:** Разработать подпрограмму сортировки массива целых чисел по возрастанию методом прямого включения (`InsertSort`).

## 1. Реализация

**Требования к проверке:**
* **Метрики:** Предусмотреть подсчет фактического количества пересылок Mф и сравнений Cф.
* **Сравнение:** Сравнить полученные данные с теоретическими оценками M и C.

## 2. Исследование зависимости от данных
Сравнить время работы по сумме трудоемкости $$M_{ф}+C_{ф}$$ метода `InsertSort` на трех типах массивов:
1. Убывающие числа.
2. Возрастающие числа.
3. Случайные числа.

> **Цель:** Сделать вывод о зависимости (или независимости) метода `InsertSort` от исходной упорядоченности массива.

## 3. Таблица трудоемкости
Заполните таблицу результатов для различных размерностей массива N.

| $$N$$| Теор.$$M+C$$| (Убыв.)$$M_{ф} + C_{ф}$$| (Случ.)$$M_{ф} + C_{ф}$$| (Возр.)$$M_{ф} + C_{ф}$$ |
| :---: | :---: | :---: | :---: | :---: |
| **100** | | | | |
| **200** | | | | |
| **300** | | | | |
| **400** | | | | |
| **500** | | | | |

## 4. Сравнение квадратичных методов
Сравнить время работы методов квадратичной трудоемкости (`SelectSort`, `BubbleSort`, `ShakerSort`, `InsertSort`) на массивах случайных чисел (по сумме $$M_{ф}+C_{ф}$$), используя результаты предыдущих заданий.

Проанализировать полученные результаты и сделать вывод о фактической трудоемкости рассмотренных методов.

Заполните таблицу:

| $$N$$| $$M_{ф}+C_{ф}$$ Select | $$M_{ф}+C_{ф}$$ Bubble | $$M_{ф}+C_{ф}$$ Shaker | $$M_{ф}+C_{ф}$$ Insert |
| :---: | :---: | :---: | :---: | :---: |
| **100** | | | | |
| **200** | | | | |
| **300** | | | | |
| **400** | | | | |
| **500** | | | | |

## 5. Визуализация и сравнение
**Задание повышенной сложности:**
Построить на экране в одной координатной плоскости графики зависимости суммарной трудоемкости $M_{ф}+C_{ф}$ от размера массива n для четырех методов квадратичной трудоемкости (для массива случайных чисел).

## 1.5. Задания по сортировке Шелла ShellSort

**Задание:** Разработать подпрограмму сортировки массива целых чисел по возрастанию методом Шелла (`ShellSort`).

## 1. Реализация

**Требования к проверке:**
* **Корректность:** Проверить правильность сортировки путем подсчета контрольной суммы элементов и числа серий в массиве.
* **Метрики:** Предусмотреть подсчет фактического количества пересылок Mф и сравнений Cф.
* **Сравнение:** Сравнить полученные данные с теоретическими оценками M и C.

## 2. Исследование трудоемкости
Исследовать трудоемкость метода `ShellSort` (по сумме $M_{ф}+C_{ф}$) для $n=100$, …, 500, где $n$ – количество элементов в массиве. Определить последовательность шагов для предварительных сортировок по формуле Д. Кнута.

Сравнить с методом прямого включения (`InsertSort`) и проанализировать полученные результаты.

Заполните таблицу:

| $$N$$| $h1 … hm$ по формуле Д.Кнута | Insert $$M_{ф}+C_{ф}$$ | Shell $$M_{ф}+C_{ф}$$ |
| :---: | :---: | :---: | :---: |
| **100** | | | |
| **200** | | | |
| **300** | | | |
| **400** | | | |
| **500** | | | |

## 3. Исследование зависимости от шагов
**Задание повышенной сложности:**
Исследовать метод `ShellSort` на зависимость трудоемкости ($$M_{ф}+C_{ф}$$) от выбора последовательности шагов. Подтвердить рекомендацию Д. Кнута или предложить лучший вариант выбора последовательности шагов.

Заполните таблицу:

| $$N$$| $h1 … hm$ по формуле Д.Кнута | Shell $$M_{ф}+C_{ф}$$ | $h1 … hm$ по другой формуле | Shell $$M_{ф}+C_{ф}$$ |
| :---: | :---: | :---: | :---: | :---: |
| **100** | | | | |
| **200** | | | | |
| **300** | | | | |
| **400** | | | | |
| **500** | | | | |

## 4. Визуализация и сравнение
**Задание повышенной сложности:**
Построить на экране в одной координатной плоскости графики зависимости суммарной трудоемкости $M_{ф}+C_{ф}$ от размера массива n для четырех методов квадратичной трудоемкости и метода Шелла `ShellSort` (для массива случайных чисел).

## 1.6. Задания по быстрому двоичному поиску

**Задание:** Разработать подпрограммы для двоичного поиска заданного элемента в упорядоченном массиве (две версии алгоритма). Ключ поиска передается в подпрограмму в качестве параметра или вводится с клавиатуры. На экран вывести найденный элемент и номер его позиции в массиве.

## 1. Реализация

**Требования к проверке:**
* **Корректность:** Проверить путем поиска первого элемента массива, последнего элемента массива и элемента, которого нет в массиве.
* **Метрики:** Предусмотреть подсчет фактического количества сравнений ($C_{ф}$).
* **Сравнение:** Сравнить полученные данные с теоретическими оценками $C$.

## 2. Сравнение версий
Сравнить трудоемкости ($C_{ф}$) двух версий алгоритма двоичного поиска заданного элемента в упорядоченном массиве. Проанализировать полученные результаты.

Заполните таблицу:

| $$N$$| $C_{ф}$ I версия | $C_{ф}$ II версия |
| :---: | :---: | :---: |
| **100** | | |
| **...** | | |
| **500** | | |
| **...** | | |
| **1000** | | |

## 3. Поиск всех элементов
**Задание повышенной сложности:**
Разработать подпрограммы поиска в упорядоченном массиве всех элементов с заданным ключом (две версии) `BSearchAll1` и `BSearchAll2`. Ключ поиска передается в подпрограмму в качестве параметра или вводится с клавиатуры. Предусмотреть подсчет фактического количества сравнений ($C_{ф}$).

Заполните таблицу:

| $$N$$| $C_{ф}$ All I версия | $C_{ф}$ All II версия |
| :---: | :---: | :---: |
| **100** | | |
| **...** | | |
| **500** | | |
| **...** | | |
| **1000** | | |

## 4. Визуализация
**Задание повышенной сложности:**
Построить на экране в одной координатной плоскости графики зависимости $C_{ф}$ от $n$ для двух версий двоичного поиска элемента с заданным ключом.

## 1.7. Задания по сортировке массивов структур

**Задание:** Разработать программу сортировки телефонного справочника по сложному (составному) ключу с использованием любого метода сортировки, кроме пузырькового.

## 1. Структура данных
Структура записи справочника должна состоять минимум из четырех полей. Исходный массив записей задать в программе (4-5 записей).

## 2. Функция сравнения
Реализовать функцию сравнения абонентов справочника по сложному ключу, состоящему минимум из двух полей записи абонента.

## 3. Вывод результатов
Реализовать вывод на экран исходного справочника и справочника, отсортированного по сложному ключу.

## 4. Гибкость сортировки
Предусмотреть возможность изменения ключа сортировки и направления сортировки телефонного справочника путем изменения функции сравнения абонентов.

## 5. Поиск в справочнике
**Задание повышенной сложности:**
Реализовать быстрый двоичный поиск в отсортированном справочнике по старшей части сложного ключа сортировки.

## 1.8. Задания по индексации массивов

**Задание:** Разработать программу сортировки телефонного справочника с использованием индексации.

## 1. Структура данных
Структура записи справочника должна состоять из четырех полей. Исходный массив записей (структур) задать в программе (4-5 записей).

## 2. Индексные массивы
Предусмотреть создание в памяти компьютера двух индексных массивов (для упорядочивания справочника по двум разным полям) с использованием любого метода сортировки, кроме пузырькового.

## 3. Вывод результатов
Предусмотреть вывод на экран справочника, отсортированного по двум разным полям с использованием построенных индексных массивов.

## 4. Поиск в справочнике
**Задание повышенной сложности:**
Реализовать быстрый двоичный поиск в справочнике (по двум разным ключам) с использованием построенных индексных массивов.

## 1.9. Задания по пирамидальной сортировке HeapSort

**Задание:** Разработать подпрограмму пирамидальной сортировки (`HeapSort`) для массива целых чисел по возрастанию.

## 1. Построение пирамиды
Разработать подпрограмму построения пирамиды из массива целых чисел. Предусмотреть подсчет фактического количества пересылок и сравнений ($M_{ф}$ и $C_{ф}$), сравнить с теоретическими оценками $M$ и $C$.

Заполните таблицу:

| $$N$$| Теор.$$M+C$$| (Убыв.)$$M_{ф} + C_{ф}$$| (Случ.)$$M_{ф} + C_{ф}$$| (Возр.)$$M_{ф} + C_{ф}$$ |
| :---: | :---: | :---: | :---: | :---: |
| **100** | | | | |
| **200** | | | | |
| **300** | | | | |
| **400** | | | | |
| **500** | | | | |

## 2. Реализация сортировки
Правильность сортировки проверить путем подсчета контрольной суммы и числа серий в массиве. Предусмотреть подсчет фактического количества пересылок и сравнений ($M_{ф}$ и $C_{ф}$), сравнить с теоретическими оценками $M$ и $C$.

## 3. Исследование зависимости от данных
Исследовать трудоемкость метода `HeapSort` на массивах убывающих, возрастающих и случайных чисел (по сумме $M_{ф}+C_{ф}$) и сделать вывод о зависимости или независимости метода от исходной упорядоченности массива.

Заполните таблицу:

| $$N$$| (Убыв.)$$M_{ф} + C_{ф}$$| (Возр.)$$M_{ф} + C_{ф}$$| (Случ.)$$M_{ф} + C_{ф}$$ |
| :---: | :---: | :---: | :---: |
| **100** | | | |
| **200** | | | |
| **300** | | | |
| **400** | | | |
| **500** | | | |

## 4. Визуализация и сравнение
**Задание повышенной сложности:**
Построить на экране в одной координатной плоскости графики зависимости суммарной трудоемкости $M_{ф}+C_{ф}$ от размера массива n для пирамидальной сортировки `HeapSort` и метода Шелла `ShellSort` (для массива случайных чисел).

## 1.10. Задания по быстрой сортировке QuickSort

**Задание:** Разработать подпрограмму сортировки массива целых чисел методом Хоара `QuickSort` (первая версия).

## 1. Реализация
Правильность сортировки проверить путем подсчета контрольной суммы и числа серий в массиве. Предусмотреть подсчет фактического количества пересылок и сравнений ($M_{ф}$ и $C_{ф}$), сравнить с теоретическими оценками $M$ и $C$.

## 2. Исследование трудоемкости
Исследовать трудоемкость сортировки методом Хоара `QuickSort` на массивах убывающих, возрастающих и случайных чисел (по сумме $M_{ф}+C_{ф}$) и сделать вывод о зависимости или независимости метода от исходной упорядоченности массива.

Заполните таблицу:

| $$N$$| (Убыв.)$$M_{ф} + C_{ф}$$| (Возр.)$$M_{ф} + C_{ф}$$| (Случ.)$$M_{ф} + C_{ф}$$ |
| :---: | :---: | :---: | :---: |
| **100** | | | |
| **200** | | | |
| **300** | | | |
| **400** | | | |
| **500** | | | |

## 3. Сравнение версий
**Задание повышенной сложности:**
Сравнить две версии сортировки методом Хоара `QuickSort` по глубине рекурсии (при вычислении глубины рекурсии не путать ее с количеством рекурсивных вызовов). Проанализировать полученные результаты.

Заполните таблицу:

| $$N$$| QuickSort1 (Убыв.) | QuickSort1 (Случ.) | QuickSort1 (Возр.) | QuickSort2 (Убыв.) | QuickSort2 (Случ.) | QuickSort2 (Возр.) |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| **100** | | | | | | |
| **200** | | | | | | |
| **300** | | | | | | |
| **400** | | | | | | |
| **500** | | | | | | |

## 4. Визуализация и сравнение
**Задание повышенной сложности:**
Построить на экране в одной координатной плоскости графики зависимости суммарной трудоемкости $M_{ф}+C_{ф}$ от размера массива n для пирамидальной сортировки `HeapSort`, метода Шелла `ShellSort` и метода Хоара `QuickSort` (для массива случайных чисел).



### 2 блок : задания по алгоритмам обработки списков и хэширования

## 2.1. Задания по обработке списков

**Задание:** Разработать функции для создания стека и очереди, а также для работы со списками.

## 1. Функции для стека
Разработать функции для создания стека:
- заполнение стека возрастающими числами;
- заполнение стека убывающими числами;
- заполнение стека случайными числами.

## 2. Функции для очереди
Разработать функции для создания очереди:
- заполнение очереди возрастающими числами;
- заполнение очереди убывающими числами;
- заполнение очереди случайными числами.

## 3. Функции для списка
Разработать функции для работы со списком:
- печать элементов списка;
- подсчет контрольной суммы элементов списка;
- подсчет количества серий в списке.

## 4. Удаление элементов
**Задание повышенной сложности:**
Разработать функцию для удаление всех элементов из списка.

## 5. Рекурсивная печать
**Задание повышенной сложности:**
Разработать рекурсивную функцию печати элементов списка в прямом и обратном порядке.

## 2.2. Задания по сортировке прямого слияния MergeSort

**Задание:** Разработать подпрограмму сортировки списка методом прямого слияния (`MergeSort`).

## 1. Расщепление списка
Разработать подпрограмму расщепления списка ($n$>=20) на два списка (через один элемент), для проверки правильности расщепления вывести на экран списки и количество элементов в них.

## 2. Слияние серий
Разработать подпрограмму слияния серий. Для проверки правильности слияния вывести на экран количество серий и контрольную сумму для всех списков. Предусмотреть подсчет фактического количества сравнений и перемещений (из стека в очередь) $C_{ф}$ и $M_{ф}$, сравнить с теоретическими оценками $C$ и $M$.

## 3. Реализация сортировки
Разработать подпрограмму сортировки списка методом прямого слияния (`MergeSort`). Предусмотреть подсчет фактического количества сравнений и перемещений (из стека в очередь) $C_{ф}$ и $M_{ф}$, сравнить с теоретическими оценками $C$ и $M$.

## 4. Исследование зависимости от данных
Сравнить время работы сортировки прямого слияния `MergeSort` на массивах убывающих, возрастающих и случайных чисел (по сумме $M_{ф}$+$C_{ф}$) и сделать вывод о зависимости (или независимости) метода `MergeSort` от исходной упорядоченности массива.

Заполните таблицу:

| $N$| Теор.$M+C$| (Убыв.)$M_{ф} + C_{ф}$| (Случ.)$M_{ф} + C_{ф}$| (Возр.)$M_{ф} + C_{ф}$ |
| :---: | :---: | :---: | :---: | :---: |
| **100** | | | | |
| **200** | | | | |
| **300** | | | | |
| **400** | | | | |
| **500** | | | | |

## 5. Визуализация и сравнение
**Задание повышенной сложности:**
Построить на экране в одной координатной плоскости графики зависимости трудоемкости ($M_{ф}$+$C_{ф}$) от размера массива $n$ для пирамидальной сортировки и метода Хоара (для массива случайных чисел), и метода прямого слияния (для списка случайных чисел).

## 2.3. Задания по цифровой сортировке DigitalSort

**Задание:** Разработать подпрограмму цифровой сортировки (`DigitalSort`) для списка целых чисел по возрастанию.

## 1. Реализация
Правильность сортировки проверить путем подсчета контрольной суммы и числа серий в списке. Предусмотреть подсчет фактического количества перемещений (из стека в очередь) $M_{ф}$, сравнить с теоретическими оценками $M$.

## 2. Применение к разным типам
Применить `DigitalSort` для сортировки списка двухбайтовых и четырехбайтовых целых чисел в прямом и обратном порядке.

## 3. Исследование зависимости от данных
Сравнить время работы цифровой сортировки `DigitalSort` на списках убывающих, возрастающих и случайных чисел (по сумме $M_{ф}$) и сделать вывод о зависимости (или независимости) сортировки `DigitalSort` от исходной упорядоченности списка.

Заполните таблицу:

| $N$| Теор.$M$| (Убыв.)$M_{ф}$| (Случ.)$M_{ф}$| (Возр.)$M_{ф}$ |
| :---: | :---: | :---: | :---: | :---: |
| **100** | | | | |
| **200** | | | | |
| **300** | | | | |
| **400** | | | | |
| **500** | | | | |

## 4. Визуализация
**Задание повышенной сложности:**
Построить на экране в одной координатной плоскости графики зависимости трудоемкости от размера массива или списка для пирамидальной сортировки, метода Хоара, метода прямого слияния и цифровой сортировки.

## 5. Сортировка фамилий
**Задание повышенной сложности:**
Применить `DigitalSort` для упорядочивания списка фамилий по возрастанию и убыванию.

## 6. Сравнение с QuickSort
**Задание повышенной сложности:**
Экспериментально определить при каком количестве байтов в сортируемых числах цифровая сортировка `DigitalSort` начинает работать медленнее, чем `QuickSort`.

## 2.4. Задания по хешированию методом прямого связывания

**Задание:** Реализовать хеширование методом прямого связывания.

## 1. Реализация
Определить размер хеш-таблицы (количество списков) так, чтобы поиск был быстрее двоичного поиска. Предусмотреть подсчет фактического количества коллизий $K_{ф}$. Вывести на экран построенные списки.

## 2. Исследование коллизий
Исследовать зависимость количества коллизий от размера хеш-таблицы (в качестве размера хеш-таблицы взять десять простых чисел от 11 до 101), построить таблицу:

| Размер хеш-таблицы | Количество исходных символов | Количество коллизий |
| :---: | :---: | :---: |
|  |  |  |

## 3. Поиск элемента
**Задание повышенной сложности:**
Организовать поиск элемента с заданным ключом для метода прямого связывания (для подтверждения выводить на экран номер списка и позицию искомого элемента в списке).

## 2.5. Задания по хешированию методом открытой адресации

**Задание:** Реализовать хеширование методом открытой адресации.

## 1. Реализация
Использовать два способа разрешения коллизий: линейные и квадратичные пробы. Предусмотреть подсчет фактического количества коллизий $K_{ф}$. Вывести на экран заполненные хеш-таблицы и сравнить их.

| Номер ячейки | 0 | 1 | 2 | 3 | … | … m-1 |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| Символ |  |  |  |  |  |  |

## 2. Сравнение коллизий
Подсчитать и сравнить количество коллизий при линейных и квадратичных пробах, в качестве размера хеш-таблицы взять десять простых чисел от 11 до 101. Построить таблицу:

| Размер хеш-таблицы | Количество исходных символов | Количество коллизий Линейные пробы | Квадратичные пробы |
| :---: | :---: | :---: | :---: |
|  |  |  |  |

## 3. Поиск элемента
**Задание повышенной сложности:**
Организовать поиск элемента с заданным ключом для метода открытой адресации при линейных и квадратичных пробах (для подтверждения выводить на экран номер позиции искомого элемента в хеш-таблицах).